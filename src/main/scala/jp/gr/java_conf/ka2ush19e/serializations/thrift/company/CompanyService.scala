/**
 * Generated by Scrooge
 *   version: 3.19.0
 *   rev: a470ba0b90af37c6dfc4b19c5258652a8e7f706e
 *   built at: 20150625-095056
 */
package jp.gr.java_conf.ka2ush19e.serializations.thrift.company

import com.twitter.scrooge.{
  LazyTProtocol,
  TFieldBlob, ThriftService, ThriftStruct,
  ThriftStructCodec, ThriftStructCodec3,
  ThriftStructFieldInfo, ThriftUtil}
import java.nio.ByteBuffer
import java.util.Arrays
import org.apache.thrift.protocol._
import org.apache.thrift.transport.TTransport
import org.apache.thrift.TApplicationException
import org.apache.thrift.transport.TMemoryBuffer
import scala.collection.immutable.{Map => immutable$Map}
import scala.collection.mutable.{
  Builder,
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}

import scala.language.higherKinds


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
trait CompanyService[+MM[_]] extends ThriftService {
  
  def get(): MM[Company]
  
  def getEmployees(): MM[Seq[Employee]]
  
  def findEmployeeByName(name: String): MM[Employee]
  
  def findEmployeeByJob(job: Job): MM[Employee]
  
  def addEmployee(name: String, job: Job): MM[Unit]
}


object CompanyService {
  
  object get$args extends ThriftStructCodec3[get$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("get_args")
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map.empty[String, String]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: get$args): Unit = {
    }
  
    def withoutPassthroughFields(original: get$args): get$args =
      new get$args(
      )
  
    override def encode(_item: get$args, _oproto: TProtocol): Unit = {
      _item.write(_oproto)
    }
  
  override def decode(_iprot: TProtocol): get$args = {
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new get$args(
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
    ): get$args =
      new get$args(
      )
  
    def unapply(_item: get$args): Boolean = true
  
  
  
  }
  
  class get$args(
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product
    with java.io.Serializable
  {
    import get$args._
      def this(
      ) = this(
        Map.empty
      )
  
  
  
    override def write(_oprot: TProtocol): Unit = {
      get$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (_passthroughFields.nonEmpty) {
        _passthroughFields.values.foreach { _.write(_oprot) }
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): get$args =
      new get$args(
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[get$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[get$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 0
  
    override def productElement(n: Int): Any = n match {
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "get$args"
  }
  
  object get$result extends ThriftStructCodec3[get$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("get_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val SuccessFieldManifest = implicitly[Manifest[Company]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        false,
        SuccessFieldManifest,
        _root_.scala.None,
        _root_.scala.None,
        immutable$Map.empty[String, String],
        immutable$Map.empty[String, String]
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map.empty[String, String]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: get$result): Unit = {
    }
  
    def withoutPassthroughFields(original: get$result): get$result =
      new get$result(
        success =
          {
            val field = original.success
            field.map { field =>
              Company.withoutPassthroughFields(field)
            }
          }
      )
  
    override def encode(_item: get$result, _oproto: TProtocol): Unit = {
      _item.write(_oproto)
    }
  
  override def decode(_iprot: TProtocol): get$result = {
      var success: _root_.scala.Option[Company] = _root_.scala.None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRUCT =>
                  success = _root_.scala.Some(readSuccessValue(_iprot))
                case _actualType =>
                  val _expectedType = TType.STRUCT
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToString(_expectedType),
                      ttypeToString(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new get$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: _root_.scala.Option[Company] = _root_.scala.None
    ): get$result =
      new get$result(
        success
      )
  
    def unapply(_item: get$result): _root_.scala.Option[_root_.scala.Option[Company]] = _root_.scala.Some(_item.success)
  
  
    @inline private def readSuccessValue(_iprot: TProtocol): Company = {
      Company.decode(_iprot)
    }
  
    @inline private def writeSuccessField(success_item: Company, _oprot: TProtocol): Unit = {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    @inline private def writeSuccessValue(success_item: Company, _oprot: TProtocol): Unit = {
      success_item.write(_oprot)
    }
  
  
  }
  
  class get$result(
      val success: _root_.scala.Option[Company],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[Company]]
    with java.io.Serializable
  {
    import get$result._
      def this(
        success: _root_.scala.Option[Company] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol): Unit = {
      get$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      if (_passthroughFields.nonEmpty) {
        _passthroughFields.values.foreach { _.write(_oprot) }
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: _root_.scala.Option[Company] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): get$result =
      new get$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[get$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[get$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "get$result"
  }
  
  object getEmployees$args extends ThriftStructCodec3[getEmployees$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("getEmployees_args")
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map.empty[String, String]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: getEmployees$args): Unit = {
    }
  
    def withoutPassthroughFields(original: getEmployees$args): getEmployees$args =
      new getEmployees$args(
      )
  
    override def encode(_item: getEmployees$args, _oproto: TProtocol): Unit = {
      _item.write(_oproto)
    }
  
  override def decode(_iprot: TProtocol): getEmployees$args = {
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new getEmployees$args(
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
    ): getEmployees$args =
      new getEmployees$args(
      )
  
    def unapply(_item: getEmployees$args): Boolean = true
  
  
  
  }
  
  class getEmployees$args(
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product
    with java.io.Serializable
  {
    import getEmployees$args._
      def this(
      ) = this(
        Map.empty
      )
  
  
  
    override def write(_oprot: TProtocol): Unit = {
      getEmployees$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (_passthroughFields.nonEmpty) {
        _passthroughFields.values.foreach { _.write(_oprot) }
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): getEmployees$args =
      new getEmployees$args(
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[getEmployees$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[getEmployees$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 0
  
    override def productElement(n: Int): Any = n match {
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "getEmployees$args"
  }
  
  object getEmployees$result extends ThriftStructCodec3[getEmployees$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("getEmployees_result")
    val SuccessField = new TField("success", TType.LIST, 0)
    val SuccessFieldManifest = implicitly[Manifest[Seq[Employee]]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        false,
        SuccessFieldManifest,
        _root_.scala.None,
        _root_.scala.Some(implicitly[Manifest[Employee]]),
        immutable$Map.empty[String, String],
        immutable$Map.empty[String, String]
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map.empty[String, String]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: getEmployees$result): Unit = {
    }
  
    def withoutPassthroughFields(original: getEmployees$result): getEmployees$result =
      new getEmployees$result(
        success =
          {
            val field = original.success
            field.map { field =>
              field.map { field =>
                Employee.withoutPassthroughFields(field)
              }
            }
          }
      )
  
    override def encode(_item: getEmployees$result, _oproto: TProtocol): Unit = {
      _item.write(_oproto)
    }
  
  override def decode(_iprot: TProtocol): getEmployees$result = {
      var success: _root_.scala.Option[Seq[Employee]] = _root_.scala.None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.LIST =>
                  success = _root_.scala.Some(readSuccessValue(_iprot))
                case _actualType =>
                  val _expectedType = TType.LIST
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToString(_expectedType),
                      ttypeToString(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new getEmployees$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: _root_.scala.Option[Seq[Employee]] = _root_.scala.None
    ): getEmployees$result =
      new getEmployees$result(
        success
      )
  
    def unapply(_item: getEmployees$result): _root_.scala.Option[_root_.scala.Option[Seq[Employee]]] = _root_.scala.Some(_item.success)
  
  
    @inline private def readSuccessValue(_iprot: TProtocol): Seq[Employee] = {
      val _list = _iprot.readListBegin()
      if (_list.size == 0) {
        _iprot.readListEnd()
        Nil
      } else {
        val _rv = new mutable$ArrayBuffer[Employee](_list.size)
        var _i = 0
        while (_i < _list.size) {
          _rv += {
            Employee.decode(_iprot)
          }
          _i += 1
        }
        _iprot.readListEnd()
        _rv
      }
    }
  
    @inline private def writeSuccessField(success_item: Seq[Employee], _oprot: TProtocol): Unit = {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    @inline private def writeSuccessValue(success_item: Seq[Employee], _oprot: TProtocol): Unit = {
      _oprot.writeListBegin(new TList(TType.STRUCT, success_item.size))
      success_item match {
        case _: IndexedSeq[_] =>
          var _i = 0
          val _size = success_item.size
          while (_i < _size) {
            val success_item_element = success_item(_i)
            success_item_element.write(_oprot)
            _i += 1
          }
        case _ =>
          success_item.foreach { success_item_element =>
            success_item_element.write(_oprot)
          }
      }
      _oprot.writeListEnd()
    }
  
  
  }
  
  class getEmployees$result(
      val success: _root_.scala.Option[Seq[Employee]],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[Seq[Employee]]]
    with java.io.Serializable
  {
    import getEmployees$result._
      def this(
        success: _root_.scala.Option[Seq[Employee]] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol): Unit = {
      getEmployees$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      if (_passthroughFields.nonEmpty) {
        _passthroughFields.values.foreach { _.write(_oprot) }
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: _root_.scala.Option[Seq[Employee]] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): getEmployees$result =
      new getEmployees$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[getEmployees$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[getEmployees$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "getEmployees$result"
  }
  
  object findEmployeeByName$args extends ThriftStructCodec3[findEmployeeByName$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("findEmployeeByName_args")
    val NameField = new TField("name", TType.STRING, 1)
    val NameFieldManifest = implicitly[Manifest[String]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        NameField,
        false,
        false,
        NameFieldManifest,
        _root_.scala.None,
        _root_.scala.None,
        immutable$Map.empty[String, String],
        immutable$Map.empty[String, String]
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map.empty[String, String]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: findEmployeeByName$args): Unit = {
    }
  
    def withoutPassthroughFields(original: findEmployeeByName$args): findEmployeeByName$args =
      new findEmployeeByName$args(
        name =
          {
            val field = original.name
            field
          }
      )
  
    override def encode(_item: findEmployeeByName$args, _oproto: TProtocol): Unit = {
      _item.write(_oproto)
    }
  
  override def decode(_iprot: TProtocol): findEmployeeByName$args = {
      var name: String = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRING =>
                  name = readNameValue(_iprot)
                case _actualType =>
                  val _expectedType = TType.STRING
                  throw new TProtocolException(
                    "Received wrong type for field 'name' (expected=%s, actual=%s).".format(
                      ttypeToString(_expectedType),
                      ttypeToString(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new findEmployeeByName$args(
        name,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      name: String
    ): findEmployeeByName$args =
      new findEmployeeByName$args(
        name
      )
  
    def unapply(_item: findEmployeeByName$args): _root_.scala.Option[String] = _root_.scala.Some(_item.name)
  
  
    @inline private def readNameValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    @inline private def writeNameField(name_item: String, _oprot: TProtocol): Unit = {
      _oprot.writeFieldBegin(NameField)
      writeNameValue(name_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    @inline private def writeNameValue(name_item: String, _oprot: TProtocol): Unit = {
      _oprot.writeString(name_item)
    }
  
  
  }
  
  class findEmployeeByName$args(
      val name: String,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[String]
    with java.io.Serializable
  {
    import findEmployeeByName$args._
      def this(
        name: String
      ) = this(
        name,
        Map.empty
      )
  
    def _1 = name
  
  
    override def write(_oprot: TProtocol): Unit = {
      findEmployeeByName$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (name ne null) writeNameField(name, _oprot)
      if (_passthroughFields.nonEmpty) {
        _passthroughFields.values.foreach { _.write(_oprot) }
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      name: String = this.name,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): findEmployeeByName$args =
      new findEmployeeByName$args(
        name,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[findEmployeeByName$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[findEmployeeByName$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.name
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "findEmployeeByName$args"
  }
  
  object findEmployeeByName$result extends ThriftStructCodec3[findEmployeeByName$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("findEmployeeByName_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val SuccessFieldManifest = implicitly[Manifest[Employee]]
    val ExField = new TField("ex", TType.STRUCT, 1)
    val ExFieldManifest = implicitly[Manifest[EmployeeNotFound]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        false,
        SuccessFieldManifest,
        _root_.scala.None,
        _root_.scala.None,
        immutable$Map.empty[String, String],
        immutable$Map.empty[String, String]
      ),
      new ThriftStructFieldInfo(
        ExField,
        true,
        false,
        ExFieldManifest,
        _root_.scala.None,
        _root_.scala.None,
        immutable$Map.empty[String, String],
        immutable$Map.empty[String, String]
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map.empty[String, String]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: findEmployeeByName$result): Unit = {
    }
  
    def withoutPassthroughFields(original: findEmployeeByName$result): findEmployeeByName$result =
      new findEmployeeByName$result(
        success =
          {
            val field = original.success
            field.map { field =>
              Employee.withoutPassthroughFields(field)
            }
          },
        ex =
          {
            val field = original.ex
            field.map { field =>
              EmployeeNotFound.withoutPassthroughFields(field)
            }
          }
      )
  
    override def encode(_item: findEmployeeByName$result, _oproto: TProtocol): Unit = {
      _item.write(_oproto)
    }
  
  override def decode(_iprot: TProtocol): findEmployeeByName$result = {
      var success: _root_.scala.Option[Employee] = _root_.scala.None
      var ex: _root_.scala.Option[EmployeeNotFound] = _root_.scala.None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRUCT =>
                  success = _root_.scala.Some(readSuccessValue(_iprot))
                case _actualType =>
                  val _expectedType = TType.STRUCT
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToString(_expectedType),
                      ttypeToString(_actualType)
                    )
                  )
              }
            case 1 =>
              _field.`type` match {
                case TType.STRUCT =>
                  ex = _root_.scala.Some(readExValue(_iprot))
                case _actualType =>
                  val _expectedType = TType.STRUCT
                  throw new TProtocolException(
                    "Received wrong type for field 'ex' (expected=%s, actual=%s).".format(
                      ttypeToString(_expectedType),
                      ttypeToString(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new findEmployeeByName$result(
        success,
        ex,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: _root_.scala.Option[Employee] = _root_.scala.None,
      ex: _root_.scala.Option[EmployeeNotFound] = _root_.scala.None
    ): findEmployeeByName$result =
      new findEmployeeByName$result(
        success,
        ex
      )
  
    def unapply(_item: findEmployeeByName$result): _root_.scala.Option[scala.Product2[Option[Employee], Option[EmployeeNotFound]]] = _root_.scala.Some(_item)
  
  
    @inline private def readSuccessValue(_iprot: TProtocol): Employee = {
      Employee.decode(_iprot)
    }
  
    @inline private def writeSuccessField(success_item: Employee, _oprot: TProtocol): Unit = {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    @inline private def writeSuccessValue(success_item: Employee, _oprot: TProtocol): Unit = {
      success_item.write(_oprot)
    }
  
    @inline private def readExValue(_iprot: TProtocol): EmployeeNotFound = {
      EmployeeNotFound.decode(_iprot)
    }
  
    @inline private def writeExField(ex_item: EmployeeNotFound, _oprot: TProtocol): Unit = {
      _oprot.writeFieldBegin(ExField)
      writeExValue(ex_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    @inline private def writeExValue(ex_item: EmployeeNotFound, _oprot: TProtocol): Unit = {
      ex_item.write(_oprot)
    }
  
  
  }
  
  class findEmployeeByName$result(
      val success: _root_.scala.Option[Employee],
      val ex: _root_.scala.Option[EmployeeNotFound],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product2[Option[Employee], Option[EmployeeNotFound]]
    with java.io.Serializable
  {
    import findEmployeeByName$result._
      def this(
        success: _root_.scala.Option[Employee] = _root_.scala.None,
        ex: _root_.scala.Option[EmployeeNotFound] = _root_.scala.None
      ) = this(
        success,
        ex,
        Map.empty
      )
  
    def _1 = success
    def _2 = ex
  
  
    override def write(_oprot: TProtocol): Unit = {
      findEmployeeByName$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      if (ex.isDefined) writeExField(ex.get, _oprot)
      if (_passthroughFields.nonEmpty) {
        _passthroughFields.values.foreach { _.write(_oprot) }
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: _root_.scala.Option[Employee] = this.success,
      ex: _root_.scala.Option[EmployeeNotFound] = this.ex,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): findEmployeeByName$result =
      new findEmployeeByName$result(
        success,
        ex,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[findEmployeeByName$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[findEmployeeByName$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case 1 => this.ex
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "findEmployeeByName$result"
  }
  
  object findEmployeeByJob$args extends ThriftStructCodec3[findEmployeeByJob$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("findEmployeeByJob_args")
    val JobField = new TField("job", TType.ENUM, 1)
    val JobFieldI32 = new TField("job", TType.I32, 1)
    val JobFieldManifest = implicitly[Manifest[Job]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        JobField,
        false,
        false,
        JobFieldManifest,
        _root_.scala.None,
        _root_.scala.None,
        immutable$Map.empty[String, String],
        immutable$Map.empty[String, String]
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map.empty[String, String]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: findEmployeeByJob$args): Unit = {
    }
  
    def withoutPassthroughFields(original: findEmployeeByJob$args): findEmployeeByJob$args =
      new findEmployeeByJob$args(
        job =
          {
            val field = original.job
            field
          }
      )
  
    override def encode(_item: findEmployeeByJob$args, _oproto: TProtocol): Unit = {
      _item.write(_oproto)
    }
  
  override def decode(_iprot: TProtocol): findEmployeeByJob$args = {
      var job: Job = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.I32 | TType.ENUM =>
                  job = readJobValue(_iprot)
                case _actualType =>
                  val _expectedType = TType.ENUM
                  throw new TProtocolException(
                    "Received wrong type for field 'job' (expected=%s, actual=%s).".format(
                      ttypeToString(_expectedType),
                      ttypeToString(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new findEmployeeByJob$args(
        job,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      job: Job
    ): findEmployeeByJob$args =
      new findEmployeeByJob$args(
        job
      )
  
    def unapply(_item: findEmployeeByJob$args): _root_.scala.Option[Job] = _root_.scala.Some(_item.job)
  
  
    @inline private def readJobValue(_iprot: TProtocol): Job = {
      Job.getOrUnknown(_iprot.readI32())
    }
  
    @inline private def writeJobField(job_item: Job, _oprot: TProtocol): Unit = {
      _oprot.writeFieldBegin(JobFieldI32)
      writeJobValue(job_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    @inline private def writeJobValue(job_item: Job, _oprot: TProtocol): Unit = {
      _oprot.writeI32(job_item.value)
    }
  
  
  }
  
  class findEmployeeByJob$args(
      val job: Job,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Job]
    with java.io.Serializable
  {
    import findEmployeeByJob$args._
      def this(
        job: Job
      ) = this(
        job,
        Map.empty
      )
  
    def _1 = job
  
  
    override def write(_oprot: TProtocol): Unit = {
      findEmployeeByJob$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (job ne null) writeJobField(job, _oprot)
      if (_passthroughFields.nonEmpty) {
        _passthroughFields.values.foreach { _.write(_oprot) }
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      job: Job = this.job,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): findEmployeeByJob$args =
      new findEmployeeByJob$args(
        job,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[findEmployeeByJob$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[findEmployeeByJob$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.job
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "findEmployeeByJob$args"
  }
  
  object findEmployeeByJob$result extends ThriftStructCodec3[findEmployeeByJob$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("findEmployeeByJob_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val SuccessFieldManifest = implicitly[Manifest[Employee]]
    val ExField = new TField("ex", TType.STRUCT, 1)
    val ExFieldManifest = implicitly[Manifest[EmployeeNotFound]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        false,
        SuccessFieldManifest,
        _root_.scala.None,
        _root_.scala.None,
        immutable$Map.empty[String, String],
        immutable$Map.empty[String, String]
      ),
      new ThriftStructFieldInfo(
        ExField,
        true,
        false,
        ExFieldManifest,
        _root_.scala.None,
        _root_.scala.None,
        immutable$Map.empty[String, String],
        immutable$Map.empty[String, String]
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map.empty[String, String]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: findEmployeeByJob$result): Unit = {
    }
  
    def withoutPassthroughFields(original: findEmployeeByJob$result): findEmployeeByJob$result =
      new findEmployeeByJob$result(
        success =
          {
            val field = original.success
            field.map { field =>
              Employee.withoutPassthroughFields(field)
            }
          },
        ex =
          {
            val field = original.ex
            field.map { field =>
              EmployeeNotFound.withoutPassthroughFields(field)
            }
          }
      )
  
    override def encode(_item: findEmployeeByJob$result, _oproto: TProtocol): Unit = {
      _item.write(_oproto)
    }
  
  override def decode(_iprot: TProtocol): findEmployeeByJob$result = {
      var success: _root_.scala.Option[Employee] = _root_.scala.None
      var ex: _root_.scala.Option[EmployeeNotFound] = _root_.scala.None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRUCT =>
                  success = _root_.scala.Some(readSuccessValue(_iprot))
                case _actualType =>
                  val _expectedType = TType.STRUCT
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToString(_expectedType),
                      ttypeToString(_actualType)
                    )
                  )
              }
            case 1 =>
              _field.`type` match {
                case TType.STRUCT =>
                  ex = _root_.scala.Some(readExValue(_iprot))
                case _actualType =>
                  val _expectedType = TType.STRUCT
                  throw new TProtocolException(
                    "Received wrong type for field 'ex' (expected=%s, actual=%s).".format(
                      ttypeToString(_expectedType),
                      ttypeToString(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new findEmployeeByJob$result(
        success,
        ex,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: _root_.scala.Option[Employee] = _root_.scala.None,
      ex: _root_.scala.Option[EmployeeNotFound] = _root_.scala.None
    ): findEmployeeByJob$result =
      new findEmployeeByJob$result(
        success,
        ex
      )
  
    def unapply(_item: findEmployeeByJob$result): _root_.scala.Option[scala.Product2[Option[Employee], Option[EmployeeNotFound]]] = _root_.scala.Some(_item)
  
  
    @inline private def readSuccessValue(_iprot: TProtocol): Employee = {
      Employee.decode(_iprot)
    }
  
    @inline private def writeSuccessField(success_item: Employee, _oprot: TProtocol): Unit = {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    @inline private def writeSuccessValue(success_item: Employee, _oprot: TProtocol): Unit = {
      success_item.write(_oprot)
    }
  
    @inline private def readExValue(_iprot: TProtocol): EmployeeNotFound = {
      EmployeeNotFound.decode(_iprot)
    }
  
    @inline private def writeExField(ex_item: EmployeeNotFound, _oprot: TProtocol): Unit = {
      _oprot.writeFieldBegin(ExField)
      writeExValue(ex_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    @inline private def writeExValue(ex_item: EmployeeNotFound, _oprot: TProtocol): Unit = {
      ex_item.write(_oprot)
    }
  
  
  }
  
  class findEmployeeByJob$result(
      val success: _root_.scala.Option[Employee],
      val ex: _root_.scala.Option[EmployeeNotFound],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product2[Option[Employee], Option[EmployeeNotFound]]
    with java.io.Serializable
  {
    import findEmployeeByJob$result._
      def this(
        success: _root_.scala.Option[Employee] = _root_.scala.None,
        ex: _root_.scala.Option[EmployeeNotFound] = _root_.scala.None
      ) = this(
        success,
        ex,
        Map.empty
      )
  
    def _1 = success
    def _2 = ex
  
  
    override def write(_oprot: TProtocol): Unit = {
      findEmployeeByJob$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      if (ex.isDefined) writeExField(ex.get, _oprot)
      if (_passthroughFields.nonEmpty) {
        _passthroughFields.values.foreach { _.write(_oprot) }
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: _root_.scala.Option[Employee] = this.success,
      ex: _root_.scala.Option[EmployeeNotFound] = this.ex,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): findEmployeeByJob$result =
      new findEmployeeByJob$result(
        success,
        ex,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[findEmployeeByJob$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[findEmployeeByJob$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case 1 => this.ex
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "findEmployeeByJob$result"
  }
  
  object addEmployee$args extends ThriftStructCodec3[addEmployee$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("addEmployee_args")
    val NameField = new TField("name", TType.STRING, 1)
    val NameFieldManifest = implicitly[Manifest[String]]
    val JobField = new TField("job", TType.ENUM, 2)
    val JobFieldI32 = new TField("job", TType.I32, 2)
    val JobFieldManifest = implicitly[Manifest[Job]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        NameField,
        false,
        false,
        NameFieldManifest,
        _root_.scala.None,
        _root_.scala.None,
        immutable$Map.empty[String, String],
        immutable$Map.empty[String, String]
      ),
      new ThriftStructFieldInfo(
        JobField,
        false,
        false,
        JobFieldManifest,
        _root_.scala.None,
        _root_.scala.None,
        immutable$Map.empty[String, String],
        immutable$Map.empty[String, String]
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map.empty[String, String]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: addEmployee$args): Unit = {
    }
  
    def withoutPassthroughFields(original: addEmployee$args): addEmployee$args =
      new addEmployee$args(
        name =
          {
            val field = original.name
            field
          },
        job =
          {
            val field = original.job
            field
          }
      )
  
    override def encode(_item: addEmployee$args, _oproto: TProtocol): Unit = {
      _item.write(_oproto)
    }
  
  override def decode(_iprot: TProtocol): addEmployee$args = {
      var name: String = null
      var job: Job = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRING =>
                  name = readNameValue(_iprot)
                case _actualType =>
                  val _expectedType = TType.STRING
                  throw new TProtocolException(
                    "Received wrong type for field 'name' (expected=%s, actual=%s).".format(
                      ttypeToString(_expectedType),
                      ttypeToString(_actualType)
                    )
                  )
              }
            case 2 =>
              _field.`type` match {
                case TType.I32 | TType.ENUM =>
                  job = readJobValue(_iprot)
                case _actualType =>
                  val _expectedType = TType.ENUM
                  throw new TProtocolException(
                    "Received wrong type for field 'job' (expected=%s, actual=%s).".format(
                      ttypeToString(_expectedType),
                      ttypeToString(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new addEmployee$args(
        name,
        job,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      name: String,
      job: Job
    ): addEmployee$args =
      new addEmployee$args(
        name,
        job
      )
  
    def unapply(_item: addEmployee$args): _root_.scala.Option[scala.Product2[String, Job]] = _root_.scala.Some(_item)
  
  
    @inline private def readNameValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    @inline private def writeNameField(name_item: String, _oprot: TProtocol): Unit = {
      _oprot.writeFieldBegin(NameField)
      writeNameValue(name_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    @inline private def writeNameValue(name_item: String, _oprot: TProtocol): Unit = {
      _oprot.writeString(name_item)
    }
  
    @inline private def readJobValue(_iprot: TProtocol): Job = {
      Job.getOrUnknown(_iprot.readI32())
    }
  
    @inline private def writeJobField(job_item: Job, _oprot: TProtocol): Unit = {
      _oprot.writeFieldBegin(JobFieldI32)
      writeJobValue(job_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    @inline private def writeJobValue(job_item: Job, _oprot: TProtocol): Unit = {
      _oprot.writeI32(job_item.value)
    }
  
  
  }
  
  class addEmployee$args(
      val name: String,
      val job: Job,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product2[String, Job]
    with java.io.Serializable
  {
    import addEmployee$args._
      def this(
        name: String,
        job: Job
      ) = this(
        name,
        job,
        Map.empty
      )
  
    def _1 = name
    def _2 = job
  
  
    override def write(_oprot: TProtocol): Unit = {
      addEmployee$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (name ne null) writeNameField(name, _oprot)
      if (job ne null) writeJobField(job, _oprot)
      if (_passthroughFields.nonEmpty) {
        _passthroughFields.values.foreach { _.write(_oprot) }
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      name: String = this.name,
      job: Job = this.job,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): addEmployee$args =
      new addEmployee$args(
        name,
        job,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[addEmployee$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[addEmployee$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.name
      case 1 => this.job
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "addEmployee$args"
  }
  
  object addEmployee$result extends ThriftStructCodec3[addEmployee$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("addEmployee_result")
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map.empty[String, String]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: addEmployee$result): Unit = {
    }
  
    def withoutPassthroughFields(original: addEmployee$result): addEmployee$result =
      new addEmployee$result(
      )
  
    override def encode(_item: addEmployee$result, _oproto: TProtocol): Unit = {
      _item.write(_oproto)
    }
  
  override def decode(_iprot: TProtocol): addEmployee$result = {
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new addEmployee$result(
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
    ): addEmployee$result =
      new addEmployee$result(
      )
  
    def unapply(_item: addEmployee$result): Boolean = true
  
  
  
  }
  
  class addEmployee$result(
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product
    with java.io.Serializable
  {
    import addEmployee$result._
      def this(
      ) = this(
        Map.empty
      )
  
  
  
    override def write(_oprot: TProtocol): Unit = {
      addEmployee$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (_passthroughFields.nonEmpty) {
        _passthroughFields.values.foreach { _.write(_oprot) }
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): addEmployee$result =
      new addEmployee$result(
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[addEmployee$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[addEmployee$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 0
  
    override def productElement(n: Int): Any = n match {
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "addEmployee$result"
  }

  import com.twitter.finagle.thrift.Protocols
  import com.twitter.util.Future

  trait FutureIface extends  CompanyService[Future] {
    
    def get(): Future[Company]
    
    def getEmployees(): Future[Seq[Employee]]
    
    def findEmployeeByName(name: String): Future[Employee]
    
    def findEmployeeByJob(job: Job): Future[Employee]
    
    def addEmployee(name: String, job: Job): Future[Unit]
  }

  class FinagledClient(
      service: com.twitter.finagle.Service[com.twitter.finagle.thrift.ThriftClientRequest, Array[Byte]],
      protocolFactory: TProtocolFactory = Protocols.binaryFactory(),
      serviceName: String = "CompanyService",
      stats: com.twitter.finagle.stats.StatsReceiver = com.twitter.finagle.stats.NullStatsReceiver)
    extends CompanyService$FinagleClient(
      service,
      protocolFactory,
      serviceName,
      stats)
    with FutureIface

  class FinagledService(
      iface: FutureIface,
      protocolFactory: TProtocolFactory)
    extends CompanyService$FinagleService(
      iface,
      protocolFactory)
}